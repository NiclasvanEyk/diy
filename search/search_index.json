{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p><code>diy</code> is a dependency injection container that reads Pythons native type annotations, so you don't have to  clutter your code with <code>Annotated</code> or other library specific markers.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>First, install the package using your favourite package manager</p> <pre><code>pip install diy\n</code></pre> <p>Then start specifying how to construct objects of a certain type:</p> <pre><code>import diy\nimport os\n\n# Our specification tells the container how to construct types\nspec = diy.Specification()\n\n# Lets start with the example of an API client, that authenticates by including\n# a secret token in a header. However, it has no hard opinions for how to \n# retrieve that token. It just takes it as a constructor parameter.\nclass ApiClient:\n  def __init__(self, token: str):\n    self.token = token\n\n# We now teach our spec how to build an instance of this class, by reading the\n# token from an environment variable.\nspec.add(lambda: ApiClient(token=os.environ[\"API_TOKEN\"]))\n</code></pre> <p>Once you are done specifying, you can construct a container based on the specification:</p> <pre><code># Pass the previously constructed spec to your container\ncontainer = diy.RuntimeContainer(spec)\n\n# If we need an instance of our client, we can simply request it from the \n# container\napi_client = container.resolve(ApiClient)\n\n# Additionally, if we have classes that only depend on classes that we already\n# know how to construct, we don't need to specify them explicitly.\nclass UserService:\n  def __init__(self, api: ApiClient):\n    self.api = api\n\n# Since the UserService class only needs an instance of ApiClient, which we \n# know how to construct, we in turn assume how a UserService should be \n# constructed.\nuser_service = container.resolve(UserService)\n</code></pre> <p>This was just a simple example. To learn about more features, you can move forward and read through the guide. It into more detail about how to solve certain edge cases, such as only defining how certain parameters should be resolved, or how to opt-out of the implicit resolving and construct the <code>UserService</code> in a different way.</p> <p>Alternatively you could look at some more in-depth examples. They show how <code>diy</code> works in a real-world scenario, and how using its <code>Container</code>s make e.g. testing easier.</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/wheather/","title":"Wheather API","text":""},{"location":"guide/","title":"Guide","text":"<p>This guide will walk you through all features of <code>diy</code>.</p>"},{"location":"guide/containers/","title":"Containers","text":"<p>Containers are the </p>"},{"location":"guide/containers/#types-of-containers","title":"Types Of Containers","text":""},{"location":"guide/containers/#functionality","title":"Functionality","text":"<p>The functionality of a container is quite simple on purpose. It mainly has two important </p>"},{"location":"guide/containers/#constructing-instances","title":"Constructing Instances","text":""},{"location":"guide/containers/#checking-presence","title":"Checking Presence","text":""},{"location":"guide/containers/#caching-values","title":"Caching Values","text":"<p>TLDR: Use <code>functools.lru_cache</code></p>"},{"location":"guide/containers/#calling-functions","title":"Calling Functions","text":"<pre><code>event_bus = EventBus()\n\ndef upload_finished(my_service: MyService):\n  # Do something with the service\n\nevent_bus.register(upload_finished)\n</code></pre>"},{"location":"guide/specifications/","title":"Specifications","text":"<p>Specifications are one half of <code>diy</code>. They determine how objects should be constructed. While <code>diy</code> tries to infer as much as possible, there are some edge cases where a sensible default cannot be inferred.</p> <p>Lets start with an example showing why we even need them:</p> <pre><code>from enum import StrEnum\n\nclass HashingAlgorithm:\n  SHA256 = \"sha256\"\n  CRC32 = \"crc32\"\n  MD5 = \"md5\"\n\nclass PasswordHasher:\n  def __init__(self, algorithm: HashingAlgorithm):\n    self.algorithm = algorithm\n\n  # ...\n</code></pre> <p>In this case, it can not be automatically inferred what <code>HashingAlgorithm</code> to use, when constructing a <code>PasswordHasher</code>. If you would try to resolve an instance of <code>PasswordHasher</code> without any specifications, you would receive</p> <pre><code>import diy\n\ncontainer = diy.RuntimeContainer()\nhasher = container.get(PasswordHasher)\n# \ud83e\udde8\ud83d\udca5 raises a diy.errors.UnresolvableDependencyError\n</code></pre> <p>To solve this, we explicitly need to tell the container how it should construct one. And this is where specs come into play.</p>"},{"location":"guide/specifications/#defining-specifications","title":"Defining Specifications","text":"<p>The simplest way to define a specification is using lambda functions.</p> <pre><code>spec = diy.Specification()\n\nspec.add(PasswordHasher, lambda: PasswordHasher(HashingAlgorithm.CRC32))\n</code></pre> <p>If a one-liner is not sufficient you can also pass a function by reference</p> <pre><code>def build_hasher():\n  return PasswordHasher(HashingAlgorithm.CRC32)\nspec.add(PasswordHasher, build_hasher)\n</code></pre> <p>However this can look a bit awkward. In this case, you may prefer utilizing decorators:</p> <pre><code>@spec.builder\ndef build_hasher() -&gt; PasswordHasher:\n  return PasswordHasher(HashingAlgorithm.CRC32)\n</code></pre> <p>Always annotate the return type when using decorators!</p> <p>Usually these kinds of annotations are optional in Python. However when using the decorator approach for registering builder functions, they are mandatory! Otherwise we'd have to run extensive analysis on the function body to check what type the function constructs. If you forget to add them a <code>diy.erros.MissingReturnTypeAnnotationError</code> is thrown.</p>"},{"location":"guide/specifications/#partial-specifications","title":"Partial Specifications","text":"<p>Sometimes the need arises to specify one or only a few parameters of a constructor.</p> <p>Consider the following example of an class that notifies users about certain events via email:</p> <pre><code>class EmailNotifier:\n  def __init__(\n    self,\n    transport: EmailTransport,  # how the emails should be delivered\n    global_bcc: str | None,     # an address to forward mails to\n  ):\n    ...\n</code></pre> <p>It accepts a <code>transport</code> instance, that adheres to the <code>EmailTransport</code> protocol. Implementations of that protocol may send the email via SMTP, a third party API, or even record the mail to memory for testing purposes. Our <code>EmailNotifier</code> does not care. However, it does accept a global email that all emails should be forwarded to. This </p>"},{"location":"guide/specifications/#conditional-specifications","title":"Conditional Specifications","text":"<p>TODO: When <code>UserService</code> needs <code>EmailNotifier</code> -&gt; use global_bcc = \"customer-support@niclasve.me\"       When <code>ImportService</code> needs <code>EmailNotifier</code> -&gt; use global_bcc = \"data-engineering@niclasve.me\"</p>"},{"location":"reference/api-docs/","title":"Generated API Documentation","text":"<p>TODO</p>"},{"location":"reference/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"reference/changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"reference/changelog/#added","title":"Added","text":"<ul> <li><code>RuntimeContainer</code>s receive a <code>Specification</code> object, that maps abstract types to builder functions.   The container then tries to build types or call functions based on the information contained in its specification.   To know what to supply for each parameter, the parameters of the constructor or function are reflected using `inspect.signature).</li> </ul>"},{"location":"reference/guiding-principles/","title":"Guiding Principles","text":"<p>This page acts as a reference for concepts and principles that are mentioned throughout the documentation.</p>"},{"location":"reference/guiding-principles/#infer-as-much-as-possible","title":"Infer as much as possible","text":"<p>If a function or constructor only requires types that the container already knows how to build, we simply supply them. You can still register a custom implementation if you want, but you are not required to.</p> <pre><code>from diy import \n</code></pre>"}]}